'use strict';

var node_buffer = require('node:buffer');
var path = require('node:path');
var childProcess = require('node:child_process');
var process = require('node:process');
var index = require('../../_virtual/index.js');
var index$1 = require('../strip-final-newline/index.js');
var index$2 = require('../npm-run-path/index.js');
var error = require('./lib/error.js');
var stdio = require('./lib/stdio.js');
require('../signal-exit/dist/mjs/index.js');
var stream = require('./lib/stream.js');
require('./lib/promise.js');
var command = require('./lib/command.js');
var verbose = require('./lib/verbose.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var childProcess__default = /*#__PURE__*/_interopDefault(childProcess);
var process__default = /*#__PURE__*/_interopDefault(process);

const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;

const getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
	const env = extendEnv ? {...process__default.default.env, ...envOption} : envOption;

	if (preferLocal) {
		return index$2.npmRunPathEnv({env, cwd: localDir, execPath});
	}

	return env;
};

const handleArguments = (file, args, options = {}) => {
	const parsed = index._parse(file, args, options);
	file = parsed.command;
	args = parsed.args;
	options = parsed.options;

	options = {
		maxBuffer: DEFAULT_MAX_BUFFER,
		buffer: true,
		stripFinalNewline: true,
		extendEnv: true,
		preferLocal: false,
		localDir: options.cwd || process__default.default.cwd(),
		execPath: process__default.default.execPath,
		encoding: 'utf8',
		reject: true,
		cleanup: true,
		all: false,
		windowsHide: true,
		verbose: verbose.verboseDefault,
		...options,
	};

	options.env = getEnv(options);

	options.stdio = stdio.normalizeStdio(options);

	if (process__default.default.platform === 'win32' && path__default.default.basename(file, '.exe') === 'cmd') {
		// #116
		args.unshift('/q');
	}

	return {file, args, options, parsed};
};

const handleOutput = (options, value, error) => {
	if (typeof value !== 'string' && !node_buffer.Buffer.isBuffer(value)) {
		// When `execaSync()` errors, we normalize it to '' to mimic `execa()`
		return error === undefined ? undefined : '';
	}

	if (options.stripFinalNewline) {
		return index$1(value);
	}

	return value;
};

function execaSync(file, args, options) {
	const parsed = handleArguments(file, args, options);
	const command$1 = command.joinCommand(file, args);
	const escapedCommand = command.getEscapedCommand(file, args);
	verbose.logCommand(escapedCommand, parsed.options);

	const input = stream.handleInputSync(parsed.options);

	let result;
	try {
		result = childProcess__default.default.spawnSync(parsed.file, parsed.args, {...parsed.options, input});
	} catch (error$1) {
		throw error.makeError({
			error: error$1,
			stdout: '',
			stderr: '',
			all: '',
			command: command$1,
			escapedCommand,
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false,
		});
	}

	const stdout = handleOutput(parsed.options, result.stdout, result.error);
	const stderr = handleOutput(parsed.options, result.stderr, result.error);

	if (result.error || result.status !== 0 || result.signal !== null) {
		const error$1 = error.makeError({
			stdout,
			stderr,
			error: result.error,
			signal: result.signal,
			exitCode: result.status,
			command: command$1,
			escapedCommand,
			parsed,
			timedOut: result.error && result.error.code === 'ETIMEDOUT',
			isCanceled: false,
			killed: result.signal !== null,
		});

		if (!parsed.options.reject) {
			return error$1;
		}

		throw error$1;
	}

	return {
		command: command$1,
		escapedCommand,
		exitCode: 0,
		stdout,
		stderr,
		failed: false,
		timedOut: false,
		isCanceled: false,
		killed: false,
	};
}

exports.execaSync = execaSync;
//# sourceMappingURL=index.js.map
