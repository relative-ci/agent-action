'use strict';

var fs = require('fs-extra');
var github = require('@actions/github');
var process_env = require('../../process.env.js');
var commitMessage = require('../git/commit-message.js');
var debug = require('../../utils/debug.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var fs__default = /*#__PURE__*/_interopDefault(fs);
var github__namespace = /*#__PURE__*/_interopNamespace(github);

async function getGitHubCommitMessage(options, logger) {
    const { owner, repo, commit, token, } = options;
    let message;
    const octokit = github__namespace.getOctokit(token);
    debug.debug(`Fetching commit message for ${commit}`);
    try {
        const res = await octokit.rest.repos.getCommit({
            owner,
            repo,
            ref: commit,
        });
        message = res?.data?.commit?.message;
    }
    catch (err) {
        debug.debug(`Error fetching commit message: ${err.message}`);
        logger.warn(err);
    }
    return message;
}
function formatBranch(branchName, baseOrg, headOrg) {
    if (!branchName) {
        return undefined;
    }
    if (!headOrg || !baseOrg) {
        return branchName;
    }
    if (headOrg === baseOrg) {
        return branchName;
    }
    return `${headOrg}:${branchName}`;
}
async function getGitHubEnv(eventFilepath, config, logger) {
    const { includeCommitMessage } = config;
    let payload;
    try {
        payload = fs__default.default.readJSONSync(eventFilepath);
    }
    catch (error) {
        // eslint-disable-next-line no-console
        console.warn(`Error reading GitHub data from ${eventFilepath}`, error.message);
    }
    const baseOrg = payload.repository.owner.login;
    // pull request
    if ('pull_request' in payload) {
        const headOrg = payload.pull_request.head?.repo?.owner?.login;
        /**
         * When running durring the pull_request event, the current commit is the GitHub merge commit
         * By default, we set an empty commit message to override the default merge commit message
         * (ex: "Merge SHA to SHA")
         */
        const env = {
            commit: payload.pull_request.head?.sha,
            commitMessage: '',
            branch: formatBranch(payload.pull_request.head?.ref, baseOrg, headOrg),
            pr: payload.pull_request.number?.toString(),
        };
        if (includeCommitMessage) {
            // Extract from git if SHA is available and part of the local git history
            if (env.commit) {
                debug.debug(`Extract commit message from git for commit ${env.commit}.`);
                env.commitMessage = commitMessage.getGitCommitMessage(env.commit);
            }
            // Extract from GitHub API if GITHUB_TOKEN is available
            const processEnv = process_env();
            if (processEnv.GITHUB_TOKEN) {
                debug.debug(`Extract commit message from GitHub API for commit ${env.commit}.`);
                const { name: repo, owner } = payload.pull_request.head.repo;
                env.commitMessage = await getGitHubCommitMessage({
                    owner: owner.login,
                    repo,
                    commit: env.commit,
                    token: processEnv.GITHUB_TOKEN,
                }, logger);
            }
            else {
                debug.debug(`GITHUB_TOKEN is missing! Skip extracting commit message from GitHub API for commit ${env.commit}.`);
            }
            // Fallback to current git commit message
            if (!env.commitMessage) {
                env.commitMessage = commitMessage.getGitCommitMessage();
            }
        }
        return env;
    }
    // workflow_run
    if ('workflow_run' in payload) {
        const headOrg = payload.workflow_run.head_repository?.owner?.login;
        const env = {
            commit: payload.workflow_run.head_commit?.id,
            branch: formatBranch(payload.workflow_run.head_branch, baseOrg, headOrg),
        };
        if (includeCommitMessage) {
            env.commitMessage = payload.workflow_run.head_commit?.message;
        }
        if ('event' in payload && payload.event === 'pull_request') {
            env.pr = payload.workflow_run?.pull_requests?.[0]?.number?.toString();
        }
        return env;
    }
    // push
    if ('head_commit' in payload && includeCommitMessage) {
        return {
            commitMessage: payload.head_commit.message,
        };
    }
    return undefined;
}

exports.getGitHubEnv = getGitHubEnv;
//# sourceMappingURL=github.js.map
