import fs from 'fs-extra';
import { getGitCommitMessage } from '../git/commit-message.js';

function formatBranch(branchName, baseOrg, headOrg) {
    if (!branchName) {
        return undefined;
    }
    if (!headOrg || !baseOrg) {
        return branchName;
    }
    if (headOrg === baseOrg) {
        return branchName;
    }
    return `${headOrg}:${branchName}`;
}
function getGitHubEnv(eventFilepath, config) {
    const { includeCommitMessage } = config;
    let payload;
    try {
        payload = fs.readJSONSync(eventFilepath);
    }
    catch (error) {
        // eslint-disable-next-line no-console
        console.warn(`Error reading GitHub data from ${eventFilepath}`, error.message);
    }
    const baseOrg = payload.repository.owner.login;
    // pull request
    if ('pull_request' in payload) {
        const headOrg = payload.pull_request.head?.repo?.owner?.login;
        /**
         * When running durring the pull_request event, the current commit is the GitHub merge commit
         * By default, we set an empty commit message to override the default merge commit message
         * (ex: "Merge SHA to SHA")
         */
        const env = {
            commit: payload.pull_request.head?.sha,
            commitMessage: '',
            branch: formatBranch(payload.pull_request.head?.ref, baseOrg, headOrg),
            pr: payload.pull_request.number?.toString(),
        };
        if (includeCommitMessage) {
            // Fallback to git if SHA is available and part of the local git history
            if (env.commit) {
                env.commitMessage = getGitCommitMessage(env.commit);
            }
            // Fallback to current git commit message
            if (!env.commitMessage) {
                env.commitMessage = getGitCommitMessage();
            }
        }
        return env;
    }
    // workflow_run
    if ('workflow_run' in payload) {
        const headOrg = payload.workflow_run.head_repository?.owner?.login;
        const env = {
            commit: payload.workflow_run.head_commit?.id,
            branch: formatBranch(payload.workflow_run.head_branch, baseOrg, headOrg),
        };
        if (includeCommitMessage) {
            env.commitMessage = payload.workflow_run.head_commit?.message;
        }
        if ('event' in payload && payload.event === 'pull_request') {
            env.pr = payload.workflow_run?.pull_requests?.[0]?.number?.toString();
        }
        return env;
    }
    // push
    if ('head_commit' in payload && includeCommitMessage) {
        return {
            commitMessage: payload.head_commit.message,
        };
    }
    return undefined;
}

export { getGitHubEnv };
//# sourceMappingURL=github.js.map
