import fs from 'fs/promises';
import path from 'path';
import fetch from 'node-fetch';
import { INGEST_ERROR, INGEST_INVALID_DATA } from './locales/en.js';
import { debug } from './utils/debug.js';
import './utils/filter-artifacts.js';
import 'child_process';
import 'env-ci';
import { maskObjectProperties } from './utils/mask-object-property.js';
import { logger } from './utils/logger.js';

async function ingest(data, params, config = {}, logger$1 = logger) {
    const { key, endpoint, branch, build, buildUrl, commit, pr, slug, service, commitMessage, agentVersion, } = params;
    const payload = {
        key,
        project: slug,
        service,
        agentVersion,
        job: {
            commit,
            branch,
            prNumber: pr,
            buildNumber: build,
            buildUrl,
            commitMessage,
        },
        rawData: data,
    };
    const formattedPayload = maskObjectProperties(payload, ['key']);
    debug('Payload size', Buffer.byteLength(JSON.stringify(payload)));
    const { payloadFilepath } = config;
    /**
     * Save payload on disk for debugging
     */
    if (payloadFilepath) {
        logger$1.info('Save payload to', payloadFilepath);
        try {
            const payloadBaseDirectory = path.dirname(payloadFilepath);
            await fs.mkdir(payloadBaseDirectory, { recursive: true });
            await fs.writeFile(payloadFilepath, JSON.stringify(formattedPayload, null, 2));
        }
        catch (err) {
            // On error, catch and log
            logger$1.warn(`Error saving payload to "${payloadFilepath}"`, err instanceof Error ? err.message : undefined);
        }
    }
    logger$1.info('Send bundle stats to RelativeCI', `branch=${branch}`, `commit=${commit}`);
    let responseData = null;
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json; charset=utf-8',
            },
            body: JSON.stringify(payload),
        });
        responseData = await response.json();
        debug('Response', responseData);
    }
    catch (error) {
        throw new Error(INGEST_ERROR, { cause: error });
    }
    if (!responseData) {
        throw new Error(INGEST_INVALID_DATA);
    }
    if (responseData.code) {
        throw new Error(responseData.message, { cause: responseData });
    }
    if (!responseData.res) {
        throw new Error(INGEST_INVALID_DATA, { cause: responseData });
    }
    return responseData;
}

export { ingest as default };
//# sourceMappingURL=ingest.js.map
